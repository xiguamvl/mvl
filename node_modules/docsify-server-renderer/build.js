'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fetch = _interopDefault(require('node-fetch'));
var marked = _interopDefault(require('marked'));
var Prism = _interopDefault(require('prismjs'));
var fs = require('fs');
var path = require('path');
var resolvePathname = _interopDefault(require('resolve-pathname'));
var debug = _interopDefault(require('debug'));

function __async(g){return new Promise(function(s,j){function c(a,x){try{var r=g[x?"throw":"next"](a);}catch(e){j(e);return}r.done?s(r.value):Promise.resolve(r.value).then(c,d);}function d(e){c(e,1);}c();})}

var inBrowser = typeof window !== 'undefined';

var isMobile = inBrowser && document.body.clientWidth <= 600;

/**
 * @see https://github.com/MoOx/pjax/blob/master/lib/is-supported.js
 */
var supportsPushState =
  inBrowser &&
  (function () {
    // Borrowed wholesale from https://github.com/defunkt/jquery-pjax
    return (
      window.history &&
      window.history.pushState &&
      window.history.replaceState &&
      // pushState isnâ€™t reliable on iOS until 5.
      !navigator.userAgent.match(
        /((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/
      )
    )
  })();

/**
 * Render github corner
 * @param  {Object} data
 * @return {String}
 */
function corner (data) {
  if (!data) { return '' }
  if (!/\/\//.test(data)) { data = 'https://github.com/' + data; }
  data = data.replace(/^git\+/, '');

  return (
    "<a href=\"" + data + "\" class=\"github-corner\" aria-label=\"View source on Github\">" +
    '<svg viewBox="0 0 250 250" aria-hidden="true">' +
    '<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>' +
    '<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>' +
    '<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>' +
    '</svg>' +
    '</a>'
  )
}

/**
 * Render main content
 */
function main (config) {
  var aside =
    '<button class="sidebar-toggle">' +
    '<div class="sidebar-toggle-button">' +
    '<span></span><span></span><span></span>' +
    '</div>' +
    '</button>' +
    '<aside class="sidebar">' +
    (config.name
      ? ("<h1><a class=\"app-name-link\" data-nosearch>" + (config.name) + "</a></h1>")
      : '') +
    '<div class="sidebar-nav"><!--sidebar--></div>' +
    '</aside>';

  return (
    (isMobile ? (aside + "<main>") : ("<main>" + aside)) +
    '<section class="content">' +
    '<article class="markdown-section" id="main"><!--main--></article>' +
    '</section>' +
    '</main>'
  )
}

/**
 * Cover Page
 */
function cover () {
  var SL = ', 100%, 85%';
  var bgc =
    'linear-gradient(to left bottom, ' +
    "hsl(" + (Math.floor(Math.random() * 255) + SL) + ") 0%," +
    "hsl(" + (Math.floor(Math.random() * 255) + SL) + ") 100%)";

  return (
    "<section class=\"cover\" style=\"background: " + bgc + "\">" +
    '<div class="cover-main"></div>' +
    '<div class="mask"></div>' +
    '</section>'
  )
}

/**
 * Render tree
 * @param  {Array} tree
 * @param  {String} tpl
 * @return {String}
 */
function tree (toc, tpl) {
  if ( tpl === void 0 ) tpl = '';

  if (!toc || !toc.length) { return '' }

  toc.forEach(function (node) {
    tpl += "<li><a class=\"section-link\" href=\"" + (node.slug) + "\">" + (node.title) + "</a></li>";
    if (node.children) {
      tpl += "<li><ul class=\"children\">" + (tree(node.children)) + "</li></ul>";
    }
  });

  return tpl
}

function helper (className, content) {
  return ("<p class=\"" + className + "\">" + (content.slice(5).trim()) + "</p>")
}

/**
 * Create a cached version of a pure function.
 */
function cached$1 (fn) {
  var cache = Object.create(null);
  return function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  }
}

/**
 * Hyphenate a camelCase string.
 */


/**
 * Simple Object.assign polyfill
 */
var merge =
  Object.assign ||
  function (to) {
    var arguments$1 = arguments;

    var hasOwn = Object.prototype.hasOwnProperty;

    for (var i = 1; i < arguments.length; i++) {
      var from = Object(arguments$1[i]);

      for (var key in from) {
        if (hasOwn.call(from, key)) {
          to[key] = from[key];
        }
      }
    }

    return to
  };

/**
 * Check if value is primitive
 */


/**
 * Perform no operation.
 */
function noop () {}

/**
 * Check if value is function
 */
function isFn (obj) {
  return typeof obj === 'function'
}

var decode = decodeURIComponent;
var encode = encodeURIComponent;

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  // Simple parse
  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');

    res[parts[0]] = parts[1] && decode(parts[1]);
  });

  return res
}

function stringifyQuery (obj, ignores) {
  if ( ignores === void 0 ) ignores = [];

  var qs = [];

  for (var key in obj) {
    if (ignores.indexOf(key) > -1) { continue }
    qs.push(
      obj[key]
        ? ((encode(key)) + "=" + (encode(obj[key]))).toLowerCase()
        : encode(key)
    );
  }

  return qs.length ? ("?" + (qs.join('&'))) : ''
}

function getPath () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return cleanPath(args.join('/'))
}

var isAbsolutePath = cached$1(function (path$$1) {
  return /(:|(\/{2}))/g.test(path$$1)
});



var cleanPath = cached$1(function (path$$1) {
  return path$$1.replace(/^\/+/, '/').replace(/([^:])\/{2,}/g, '$1/')
});

var cached$$1 = {};

function getAlias (path$$1, alias, last) {
  var match = Object.keys(alias).filter(function (key) {
    var re = cached$$1[key] || (cached$$1[key] = new RegExp(("^" + key + "$")));
    return re.test(path$$1) && path$$1 !== last
  })[0];

  return match
    ? getAlias(path$$1.replace(cached$$1[match], alias[match]), alias, path$$1)
    : path$$1
}

function getFileName (path$$1) {
  return /\.(md|html)$/g.test(path$$1)
    ? path$$1
    : /\/$/g.test(path$$1) ? (path$$1 + "README.md") : (path$$1 + ".md")
}

var History = function History (config) {
  this.config = config;
};

History.prototype.getBasePath = function getBasePath () {
  return this.config.basePath
};

History.prototype.getFile = function getFile (path$$1, isRelative) {
  path$$1 = path$$1 || this.getCurrentPath();

  var ref = this;
    var config = ref.config;
  var base = this.getBasePath();

  path$$1 = config.alias ? getAlias(path$$1, config.alias) : path$$1;
  path$$1 = getFileName(path$$1);
  path$$1 = path$$1 === '/README.md' ? config.homepage || path$$1 : path$$1;
  path$$1 = isAbsolutePath(path$$1) ? path$$1 : getPath(base, path$$1);

  if (isRelative) {
    path$$1 = path$$1.replace(new RegExp(("^" + base)), '');
  }

  return path$$1
};

History.prototype.onchange = function onchange (cb) {
    if ( cb === void 0 ) cb = noop;

  cb();
};

History.prototype.getCurrentPath = function getCurrentPath () {};

History.prototype.normalize = function normalize () {};

History.prototype.parse = function parse () {};

History.prototype.toURL = function toURL () {};

var AbstractHistory = (function (History$$1) {
  function AbstractHistory (config) {
    History$$1.call(this, config);
    this.mode = 'abstract';
  }

  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.parse = function parse (path$$1) {
    var query = '';

    var queryIndex = path$$1.indexOf('?');
    if (queryIndex >= 0) {
      query = path$$1.slice(queryIndex + 1);
      path$$1 = path$$1.slice(0, queryIndex);
    }

    return {
      path: path$$1,
      file: this.getFile(path$$1),
      query: parseQuery(query)
    }
  };

  AbstractHistory.prototype.toURL = function toURL (path$$1, params, currentRoute) {
    var local = currentRoute && path$$1[0] === '#';
    var route = this.parse(path$$1);

    route.query = merge({}, route.query, params);
    path$$1 = route.path + stringifyQuery(route.query);
    path$$1 = path$$1.replace(/\.md(\?)|\.md$/, '$1');

    if (local) { path$$1 = currentRoute + path$$1; }

    return cleanPath('/' + path$$1)
  };

  return AbstractHistory;
}(History));

/**
 * gen toc tree
 * @link https://github.com/killercup/grock/blob/5280ae63e16c5739e9233d9009bc235ed7d79a50/styles/solarized/assets/js/behavior.coffee#L54-L81
 * @param  {Array} toc
 * @param  {Number} maxLevel
 * @return {Array}
 */
function genTree (toc, maxLevel) {
  var headlines = [];
  var last = {};

  toc.forEach(function (headline) {
    var level = headline.level || 1;
    var len = level - 1;

    if (level > maxLevel) { return }
    if (last[len]) {
      last[len].children = (last[len].children || []).concat(headline);
    } else {
      headlines.push(headline);
    }
    last[level] = headline;
  });

  return headlines
}

var cache = {};
var re = /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,.\/:;<=>?@\[\]^`{|}~]/g;

function lower (string) {
  return string.toLowerCase()
}

function slugify (str) {
  if (typeof str !== 'string') { return '' }

  var slug = str
    .trim()
    .replace(/[A-Z]+/g, lower)
    .replace(/<[^>\d]+>/g, '')
    .replace(re, '')
    .replace(/\s/g, '-')
    .replace(/-+/g, '-')
    .replace(/^(\d)/, '_$1');
  var count = cache[slug];

  count = cache.hasOwnProperty(slug) ? count + 1 : 0;
  cache[slug] = count;

  if (count) {
    slug = slug + '-' + count;
  }

  return slug
}

slugify.clear = function () {
  cache = {};
};

function replace (m, $1) {
  return '<img class="emoji" src="https://assets-cdn.github.com/images/icons/emoji/' + $1 + '.png" alt="' + $1 + '" />'
}

function emojify (text) {
  return text
    .replace(/<(pre|template|code)[^>]*?>[\s\S]+?<\/(pre|template|code)>/g, function (m) { return m.replace(/:/g, '__colon__'); })
    .replace(/:(\w+?):/ig, (inBrowser && window.emojify) || replace)
    .replace(/__colon__/g, ':')
}

var cachedLinks = {};
function getAndRemoveConfig (str) {
  if ( str === void 0 ) str = '';

  var config = {};

  if (str) {
    str = str
      .replace(/:([\w-]+)=?([\w-]+)?/g, function (m, key, value) {
        config[key] = value || true;
        return ''
      })
      .trim();
  }

  return { str: str, config: config }
}

var Compiler = function Compiler (config, router) {
  this.config = config;
  this.router = router;
  this.cacheTree = {};
  this.toc = [];
  this.linkTarget = config.externalLinkTarget || '_blank';
  this.contentBase = router.getBasePath();

  var renderer = this._initRenderer();
  var compile;
  var mdConf = config.markdown || {};

  if (isFn(mdConf)) {
    compile = mdConf(marked, renderer);
  } else {
    marked.setOptions(
      merge(mdConf, {
        renderer: merge(renderer, mdConf.renderer)
      })
    );
    compile = marked;
  }

  this.compile = cached$1(function (text) {
    var html = '';

    if (!text) { return text }

    html = compile(text);
    html = config.noEmoji ? html : emojify(html);
    slugify.clear();

    return html
  });
};

Compiler.prototype.matchNotCompileLink = function matchNotCompileLink (link) {
  var links = this.config.noCompileLinks;

  for (var i = 0; i < links.length; i++) {
    var n = links[i];
    var re = cachedLinks[n] || (cachedLinks[n] = new RegExp(("^" + n + "$")));

    if (re.test(link)) {
      return link
    }
  }
};

Compiler.prototype._initRenderer = function _initRenderer () {
  var renderer = new marked.Renderer();
  var ref = this;
    var linkTarget = ref.linkTarget;
    var router = ref.router;
    var contentBase = ref.contentBase;
  var _self = this;
  var origin = {};

  /**
   * render anchor tag
   * @link https://github.com/chjj/marked#overriding-renderer-methods
   */
  origin.heading = renderer.heading = function (text, level) {
    var nextToc = { level: level, title: text };

    if (/{docsify-ignore}/g.test(text)) {
      text = text.replace('{docsify-ignore}', '');
      nextToc.title = text;
      nextToc.ignoreSubHeading = true;
    }

    if (/{docsify-ignore-all}/g.test(text)) {
      text = text.replace('{docsify-ignore-all}', '');
      nextToc.title = text;
      nextToc.ignoreAllSubs = true;
    }

    var slug = slugify(text);
    var url = router.toURL(router.getCurrentPath(), { id: slug });
    nextToc.slug = url;
    _self.toc.push(nextToc);

    return ("<h" + level + " id=\"" + slug + "\"><a href=\"" + url + "\" data-id=\"" + slug + "\" class=\"anchor\"><span>" + text + "</span></a></h" + level + ">")
  };
  // highlight code
  origin.code = renderer.code = function (code, lang) {
      if ( lang === void 0 ) lang = '';

    var hl = Prism.highlight(
      code,
      Prism.languages[lang] || Prism.languages.markup
    );

    return ("<pre v-pre data-lang=\"" + lang + "\"><code class=\"lang-" + lang + "\">" + hl + "</code></pre>")
  };
  origin.link = renderer.link = function (href, title, text) {
      if ( title === void 0 ) title = '';

    var attrs = '';

    var ref = getAndRemoveConfig(title);
      var str = ref.str;
      var config = ref.config;
    title = str;

    if (
      !/:|(\/{2})/.test(href) &&
      !_self.matchNotCompileLink(href) &&
      !config.ignore
    ) {
      href = router.toURL(href, null, router.getCurrentPath());
    } else {
      attrs += " target=\"" + linkTarget + "\"";
    }

    if (config.target) {
      attrs += ' target=' + config.target;
    }

    if (config.disabled) {
      attrs += ' disabled';
      href = 'javascript:void(0)';
    }

    if (title) {
      attrs += " title=\"" + title + "\"";
    }

    return ("<a href=\"" + href + "\"" + attrs + ">" + text + "</a>")
  };
  origin.paragraph = renderer.paragraph = function (text) {
    if (/^!&gt;/.test(text)) {
      return helper('tip', text)
    } else if (/^\?&gt;/.test(text)) {
      return helper('warn', text)
    }
    return ("<p>" + text + "</p>")
  };
  origin.image = renderer.image = function (href, title, text) {
    var url = href;
    var attrs = '';

    var ref = getAndRemoveConfig(title);
      var str = ref.str;
      var config = ref.config;
    title = str;

    if (config['no-zoom']) {
      attrs += ' data-no-zoom';
    }

    if (title) {
      attrs += " title=\"" + title + "\"";
    }

    if (!isAbsolutePath(href)) {
      url = getPath(contentBase, href);
    }

    return ("<img src=\"" + url + "\"data-origin=\"" + href + "\" alt=\"" + text + "\"" + attrs + ">")
  };

  var CHECKED_RE = /^\[([ x])\] +/;
  origin.listitem = renderer.listitem = function (text) {
    var checked = CHECKED_RE.exec(text);
    if (checked) {
      text = text.replace(CHECKED_RE, ("<input type=\"checkbox\" " + (checked[1] === 'x' ? 'checked' : '') + " />"));
    }
    return ("<li>" + text + "</li>\n")
  };

  renderer.origin = origin;

  return renderer
};

/**
 * Compile sidebar
 */
Compiler.prototype.sidebar = function sidebar (text, level) {
  var currentPath = this.router.getCurrentPath();
  var html = '';

  if (text) {
    html = this.compile(text);
    html = html && html.match(/<ul[^>]*>([\s\S]+)<\/ul>/g)[0];
  } else {
    var tree$$1 = this.cacheTree[currentPath] || genTree(this.toc, level);
    html = tree(tree$$1, '<ul>');
    this.cacheTree[currentPath] = tree$$1;
  }

  return html
};

/**
 * Compile sub sidebar
 */
Compiler.prototype.subSidebar = function subSidebar (level) {
  if (!level) {
    this.toc = [];
    return
  }
  var currentPath = this.router.getCurrentPath();
  var ref = this;
    var cacheTree = ref.cacheTree;
    var toc = ref.toc;

  toc[0] && toc[0].ignoreAllSubs && toc.splice(0);
  toc[0] && toc[0].level === 1 && toc.shift();

  for (var i = 0; i < toc.length; i++) {
    toc[i].ignoreSubHeading && toc.splice(i, 1) && i--;
  }

  var tree$$1 = cacheTree[currentPath] || genTree(toc, level);

  cacheTree[currentPath] = tree$$1;
  this.toc = [];
  return tree(tree$$1, '<ul class="app-sub-sidebar">')
};

Compiler.prototype.article = function article (text) {
  return this.compile(text)
};

/**
 * Compile cover page
 */
Compiler.prototype.cover = function cover$$1 (text) {
  var cacheToc = this.toc.slice();
  var html = this.compile(text);

  this.toc = cacheToc.slice();

  return html
};

function cwd () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return path.resolve.apply(void 0, [ process.cwd() ].concat( args ))
}

function mainTpl (config) {
  var html = "<nav class=\"app-nav" + (config.repo
    ? ''
    : ' no-badge') + "\"><!--navbar--></nav>";

  if (config.repo) {
    html += corner(config.repo);
  }
  if (config.coverpage) {
    html += cover();
  }

  html += main(config);

  return html
}

var Renderer = function Renderer (ref) {
  var this$1 = this;
  var template = ref.template;
  var config = ref.config;
  var cache = ref.cache;

  this.html = template;
  this.config = config = Object.assign({}, config, {
    routerMode: 'history'
  });
  this.cache = cache;

  this.router = new AbstractHistory(config);
  this.compiler = new Compiler(config, this.router);

  this.router.getCurrentPath = function () { return this$1.url; };
  this._renderHtml(
    'inject-config',
    ("<script>window.$docsify = " + (JSON.stringify(config)) + "</script>")
  );
  this._renderHtml('inject-app', mainTpl(config));

  this.template = this.html;
};

Renderer.prototype._getPath = function _getPath (url) {
  var file = this.router.getFile(url);

  return isAbsolutePath(file) ? file : cwd(("./" + file))
};

Renderer.prototype.renderToString = function renderToString (url) {return __async(function*(){
  this.url = url = this.router.parse(url).path;
  var ref = this.config;
    var loadSidebar = ref.loadSidebar;
    var loadNavbar = ref.loadNavbar;

  var mainFile = this._getPath(url);
  this._renderHtml('main', yield this._render(mainFile));

  if (loadSidebar) {
    var name = loadSidebar === true ? '_sidebar.md' : loadSidebar;
    var sidebarFile = this._getPath(path.resolve(url, ("./" + name)));
    this._renderHtml('sidebar', yield this._render(sidebarFile, 'sidebar'));
  }

  if (loadNavbar) {
    var name$1 = loadNavbar === true ? '_navbar.md' : loadNavbar;
    var navbarFile = this._getPath(path.resolve(url, ("./" + name$1)));
    this._renderHtml('navbar', yield this._render(navbarFile, 'navbar'));
  }

  var html = this.html;
  this.html = this.template;

  return html
}.call(this))};

Renderer.prototype._renderHtml = function _renderHtml (match, content) {
  this.html = this.html.replace(new RegExp(("<!--" + match + "-->"), 'g'), content);

  return this.html
};

Renderer.prototype._render = function _render (path$$1, type) {return __async(function*(){
  var html = yield this._loadFile(path$$1);
  var ref = this.config;
    var subMaxLevel = ref.subMaxLevel;
    var maxLevel = ref.maxLevel;

  switch (type) {
    case 'sidebar':
      html =
        this.compiler.sidebar(html, maxLevel) +
        "<script>window.__SUB_SIDEBAR__ = " + (JSON.stringify(
          this.compiler.subSidebar(subMaxLevel)
        )) + "</script>";
      break
    case 'cover':
      html = this.compiler.cover(html);
      break
    case 'navbar':
    case 'article':
    default:
      html = this.compiler.compile(html);
      break
  }

  return html
}.call(this))};

Renderer.prototype._loadFile = function _loadFile (filePath) {return __async(function*(){
  debug('docsify')(("load > " + filePath));
  var content;
  try {
    if (isAbsolutePath(filePath)) {
      var res = yield fetch(filePath);
      if (!res.ok) { throw Error() }
      content = yield res.text();
      this.lock = 0;
    } else {
      content = yield fs.readFileSync(filePath, 'utf8');
      this.lock = 0;
    }
    return content
  } catch (e) {
    this.lock = this.lock || 0;
    if (++this.lock > 10) {
      this.lock = 0;
      return
    }

    var fileName = path.basename(filePath);

    return yield this._loadFile(resolvePathname(("../" + fileName), filePath))
  }
}.call(this))};

Renderer.version = '4.5.3';

module.exports = Renderer;
